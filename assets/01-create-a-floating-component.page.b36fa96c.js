var rt=Object.defineProperty,lt=Object.defineProperties;var st=Object.getOwnPropertyDescriptors;var D=Object.getOwnPropertySymbols;var at=Object.prototype.hasOwnProperty,ct=Object.prototype.propertyIsEnumerable;var F=(t,e,n)=>e in t?rt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,d=(t,e)=>{for(var n in e||(e={}))at.call(e,n)&&F(t,n,e[n]);if(D)for(var n of D(e))ct.call(e,n)&&F(t,n,e[n]);return t},w=(t,e)=>lt(t,st(e));import{d as O,l as $,m as ft,n as ut,o as B,f as V,q as A,j,t as pt,v as I,w as dt,x as ht,y as X,F as gt,k as _,h as c}from"./vendor.1ba3453e.js";import{a as Y}from"./_default.page.client.ts.fc04be00.js";function z(t){return t.split("-")[0]}function mt(t){return t.split("-")[1]}function wt(t){return["top","bottom"].includes(z(t))?"x":"y"}function yt(t){return t==="y"?"height":"width"}function U(t){let{reference:e,floating:n,placement:o}=t;const i=e.x+e.width/2-n.width/2,s=e.y+e.height/2-n.height/2;let l;switch(z(o)){case"top":l={x:i,y:e.y-n.height};break;case"bottom":l={x:i,y:e.y+e.height};break;case"right":l={x:e.x+e.width,y:s};break;case"left":l={x:e.x-n.width,y:s};break;default:l={x:e.x,y:e.y}}const r=wt(o),a=yt(r);switch(mt(o)){case"start":l[r]=l[r]-(e[a]/2-n[a]/2);break;case"end":l[r]=l[r]+(e[a]/2-n[a]/2);break}return l}const vt=async(t,e,n)=>{const{placement:o="bottom",strategy:i="absolute",middleware:s=[],platform:l}=n;let r=await l.getElementRects({reference:t,floating:e,strategy:i}),{x:a,y:m}=U(w(d({},r),{placement:o})),f=o,x={};for(let C=0;C<s.length;C++){const{name:ot,fn:it}=s[C],{x:N,y:H,data:M,reset:E}=await it({x:a,y:m,initialPlacement:o,placement:f,strategy:i,middlewareData:x,rects:r,platform:l,elements:{reference:t,floating:e}});if(a=N!=null?N:a,m=H!=null?H:m,x=w(d({},x),{[ot]:M!=null?M:{}}),E){typeof E=="object"&&E.placement&&(f=E.placement),r=await l.getElementRects({reference:t,floating:e,strategy:i}),{x:a,y:m}=U(w(d({},r),{placement:f})),C=-1;continue}}return{x:a,y:m,placement:f,strategy:i,middlewareData:x}};function q(t){return w(d({},t),{top:t.y,left:t.x,right:t.x+t.width,bottom:t.y+t.height})}function k(t){return(t==null?void 0:t.toString())==="[object Window]"}function h(t){if(t==null)return window;if(!k(t)){const e=t.ownerDocument;return e&&e.defaultView||window}return t}function v(t){return h(t).getComputedStyle(t)}function u(t){return k(t)?"":t?(t.nodeName||"").toLowerCase():""}function p(t){return t instanceof h(t).HTMLElement}function R(t){return t instanceof h(t).Element}function bt(t){return t instanceof h(t).Node}function G(t){const e=h(t).ShadowRoot;return t instanceof e||t instanceof ShadowRoot}function T(t){const{overflow:e,overflowX:n,overflowY:o}=v(t);return/auto|scroll|overlay|hidden/.test(e+o+n)}function xt(t){return["table","td","th"].includes(u(t))}function J(t){const e=navigator.userAgent.toLowerCase().includes("firefox"),n=v(t);return n.transform!=="none"||n.perspective!=="none"||n.contain==="paint"||["transform","perspective"].includes(n.willChange)||e&&n.willChange==="filter"||e&&(n.filter?n.filter!=="none":!1)}function y(t,e){e===void 0&&(e=!1);const n=t.getBoundingClientRect();let o=1,i=1;return e&&p(t)&&(o=t.offsetWidth>0&&Math.round(n.width)/t.offsetWidth||1,i=t.offsetHeight>0&&Math.round(n.height)/t.offsetHeight||1),{width:n.width/o,height:n.height/i,top:n.top/i,right:n.right/o,bottom:n.bottom/i,left:n.left/o,x:n.left/o,y:n.top/i}}function g(t){return((bt(t)?t.ownerDocument:t.document)||window.document).documentElement}function P(t){return k(t)?{scrollLeft:t.pageXOffset,scrollTop:t.pageYOffset}:{scrollLeft:t.scrollLeft,scrollTop:t.scrollTop}}function K(t){return y(g(t)).left+P(t).scrollLeft}function Ct(t){const e=y(t);return Math.round(e.width)!==t.offsetWidth||Math.round(e.height)!==t.offsetHeight}function Et(t,e,n){const o=p(e),i=g(e),s=y(t,o&&Ct(e));let l={scrollLeft:0,scrollTop:0};const r={x:0,y:0};if(o||!o&&n!=="fixed")if((u(e)!=="body"||T(i))&&(l=P(e)),p(e)){const a=y(e,!0);r.x=a.x+e.clientLeft,r.y=a.y+e.clientTop}else i&&(r.x=K(i));return{x:s.left+l.scrollLeft-r.x,y:s.top+l.scrollTop-r.y,width:s.width,height:s.height}}function L(t){return u(t)==="html"?t:t.assignedSlot||t.parentNode||(G(t)?t.host:null)||g(t)}function Q(t){return!p(t)||getComputedStyle(t).position==="fixed"?null:t.offsetParent}function Rt(t){let e=L(t);for(;p(e)&&!["html","body"].includes(u(e));){if(J(e))return e;e=e.parentNode}return null}function S(t){const e=h(t);let n=Q(t);for(;n&&xt(n)&&getComputedStyle(n).position==="static";)n=Q(n);return n&&(u(n)==="html"||u(n)==="body"&&getComputedStyle(n).position==="static"&&!J(n))?e:n||Rt(t)||e}function Z(t){return{width:t.offsetWidth,height:t.offsetHeight}}function Tt(t){let{rect:e,offsetParent:n,strategy:o}=t;const i=p(n),s=g(n);if(n===s)return e;let l={scrollLeft:0,scrollTop:0};const r={x:0,y:0};if((i||!i&&o!=="fixed")&&((u(n)!=="body"||T(s))&&(l=P(n)),p(n))){const a=y(n,!0);r.x=a.x+n.clientLeft,r.y=a.y+n.clientTop}return w(d({},e),{x:e.x-l.scrollLeft+r.x,y:e.y-l.scrollTop+r.y})}function Pt(t){const e=h(t),n=g(t),o=e.visualViewport;let i=n.clientWidth,s=n.clientHeight,l=0,r=0;return o&&(i=o.width,s=o.height,Math.abs(e.innerWidth/o.scale-o.width)<.001&&(l=o.offsetLeft,r=o.offsetTop)),{width:i,height:s,x:l,y:r}}const tt=Math.min,b=Math.max;function Lt(t){var e;const n=g(t),o=P(t),i=(e=t.ownerDocument)==null?void 0:e.body,s=b(n.scrollWidth,n.clientWidth,i?i.scrollWidth:0,i?i.clientWidth:0),l=b(n.scrollHeight,n.clientHeight,i?i.scrollHeight:0,i?i.clientHeight:0);let r=-o.scrollLeft+K(t);const a=-o.scrollTop;return v(i||n).direction==="rtl"&&(r+=b(n.clientWidth,i?i.clientWidth:0)-s),{width:s,height:l,x:r,y:a}}function et(t){return["html","body","#document"].includes(u(t))?t.ownerDocument.body:p(t)&&T(t)?t:et(L(t))}function W(t,e){var n;e===void 0&&(e=[]);const o=et(t),i=o===((n=t.ownerDocument)==null?void 0:n.body),s=h(o),l=i?[s].concat(s.visualViewport||[],T(o)?o:[]):o,r=e.concat(l);return i?r:r.concat(W(L(l)))}function Wt(t,e){const n=e.getRootNode==null?void 0:e.getRootNode();if(t.contains(e))return!0;if(n&&G(n)){let o=e;do{if(o&&t===o)return!0;o=o.parentNode||o.host}while(o)}return!1}function _t(t){const e=y(t),n=e.top+t.clientTop,o=e.left+t.clientLeft;return{top:n,left:o,x:o,y:n,right:o+t.clientWidth,bottom:n+t.clientHeight,width:t.clientWidth,height:t.clientHeight}}function nt(t,e){return e==="viewport"?q(Pt(t)):R(e)?_t(e):q(Lt(g(t)))}function kt(t){const e=W(L(t)),n=["absolute","fixed"].includes(v(t).position),o=n&&p(t)?S(t):t;return R(o)?e.filter(i=>R(i)&&Wt(i,o)&&u(i)!=="body"&&(n?v(i).position!=="static":!0)):[]}function St(t){let{element:e,boundary:n,rootBoundary:o}=t;const s=[...n==="clippingParents"?kt(e):[].concat(n),o],l=s[0],r=s.reduce((a,m)=>{const f=nt(e,m);return a.top=b(f.top,a.top),a.right=tt(f.right,a.right),a.bottom=tt(f.bottom,a.bottom),a.left=b(f.left,a.left),a},nt(e,l));return r.width=r.right-r.left,r.height=r.bottom-r.top,r.x=r.left,r.y=r.top,r}const Nt={getElementRects:t=>{let{reference:e,floating:n,strategy:o}=t;return{reference:Et(e,S(n),o),floating:w(d({},Z(n)),{x:0,y:0})}},convertOffsetParentRelativeRectToViewportRelativeRect:t=>Tt(t),getOffsetParent:t=>{let{element:e}=t;return S(e)},isElement:t=>R(t),getDocumentElement:t=>{let{element:e}=t;return g(e)},getClippingClientRect:t=>St(t),getDimensions:t=>{let{element:e}=t;return Z(e)}},Ht=(t,e,n)=>vt(t,e,d({platform:Nt},n)),Mt=O({setup(t){const e=$(null),n=$(null),o=ft({x:0,y:0});async function i(){Y(e.value!==null&&n.value!==null);const{x:s,y:l}=await Ht(e.value,n.value,{placement:"top"});Object.assign(o,{x:s,y:l})}return ut(async()=>{Y(e.value!==null&&n.value!==null),i(),[...W(e.value),...W(n.value)].forEach(s=>{s.addEventListener("scroll",i),s.addEventListener("resize",i)})}),(s,l)=>(B(),V("span",dt({ref_key:"reference",ref:e},s.$attrs),[A(s.$slots,"default"),j("div",{ref_key:"floating",ref:n,class:"absolute top-0 left-0",style:pt({transform:`translate(${I(o).x}px, ${I(o).y}px)`})},[A(s.$slots,"floating")],4)],16))}}),Dt=_(" Result: demo sentence with "),Ft=_(" floating "),Ot=j("div",{class:"px-2 py-1 bg-white border rounded-lg"},"tooltip",-1),$t=_(" element. "),Bt=O({setup(t){return(e,n)=>(B(),V(gt,null,[Dt,ht(Mt,{class:"inline-block underline"},{floating:X(()=>[Ot]),default:X(()=>[Ft]),_:1}),$t],64))}}),Vt=[c("h1",{},["Create a floating component"]),c("p",{},["You want to show a menu or tooltip, after user clicks / hovers a button."]),c("p",{},["Floating components doesn\u2019t disrupt the flow of the main content. Therefore, we actually don\u2019t have to make any modification to the main content. The biggest concerns of building a floating component are about the floating element itself:"]),c("ol",{},[c("li",{},["We should decide the position of the floating element relative to the reference element."]),c("li",{},["We want to control when and how it appears / disappears."])]),c("p",{},["For the first concern, there is a dedicated library specifically for floating element positioning called ",c("a",{href:"http://floating-ui.com"},["Floating UI"])," (formerly ",c("a",{href:"https://popper.js.org"},["Popper.js"]),"). It helps us to calculate the relative position of the floating element to the reference, with a handy collection of positioning strategies supported. While it is good to use it as the documentation demonstrates, we may still want to integrate it into Vue, in order to have a more consistent API with better organization and control of logic."]),c("p",{},["The Vue API should wrap the reference element, and also be able to write the floating component within it. We can achieve this by using ",c("a",{href:"https://v3.vuejs.org/guide/component-slots.html#named-slots"},["named slots"]),". The inital API design would be like this:"]),c("pre",{},[`<Float class="inline-block underline">
  floating
  <template #floating>
    <div class="px-2 py-1 bg-white border rounded-lg">tooltip</div>
  </template>
</Float>
`]),c("p",{},["We write a basic component positioning logic:"]),c("pre",{},[`<template>
  <span ref="reference" v-bind="$attrs">
    <slot />
    <div
      ref="floating"
      class="absolute top-0 left-0"
      :style="{ transform: \`translate(\${position.x}px, \${position.y}px)\` }"
    >
      <slot name="floating" />
    </div>
  </span>
</template>
<script lang="ts" setup>
import { onMounted, ref, reactive, Ref } from 'vue'
import { computePosition, getScrollParents } from '@floating-ui/dom'
const reference: Ref<HTMLElement | null> = ref(null)
const floating: Ref<HTMLElement | null> = ref(null)
const position = reactive({ x: 0, y: 0 })
async function update() {
  assert(reference.value !== null && floating.value !== null)
  const { x, y } = await computePosition(reference.value, floating.value, {
    placement: 'top',
  })
  Object.assign(position, { x, y })
}
onMounted(async () => {
  assert(reference.value !== null && floating.value !== null)
  update()
  getScrollParents(reference.value).forEach((el) => {
    el.addEventListener('scroll', update)
    el.addEventListener('resize', update)
  })
})
<\/script>
`]),c(Bt,{}),c("p",{},["Some key features in this implementation:"]),c("ol",{},[c("li",{},["We put the floating element intially at top-left corner with ",c("code",{},["position: absolute"]),", to make sure it can be moved correctly and efficiently using CSS transform ",c("code",{},["translate()"]),"."]),c("li",{},["We use reactive variable ",c("code",{},["position"])," to track position change, and use inline style binding to actually set position. The position is calculated by Floating UI in function ",c("code",{},["update"]),"."]),c("li",{},["It is made explicit that the position of the floating element is recalculated whenever the reference element changes position (when scroll or resize happens to one of its ancestors)."])])];var Xt={render(){return Vt}};const Yt={title:"Create a floating component",layout:"book"};export{Xt as default,Yt as frontmatter,Vt as nodes};
